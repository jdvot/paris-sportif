/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * WinRate AI API
 * API de predictions de paris sportifs sur le football europeen
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BankrollResponse,
  BankrollSettings,
  BetCreate,
  BetResponse,
  BetUpdate,
  GetKellySuggestionApiV1BetsKellyGetParams,
  HTTPErrorResponse,
  HTTPValidationError,
  KellySuggestion,
  ListBetsApiV1BetsGetParams
} from '../../models';

import { customInstance } from '../../custom-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get user's bankroll summary.
 * @summary Get Bankroll
 */
export type getBankrollApiV1BetsBankrollGetResponse200 = {
  data: BankrollResponse
  status: 200
}

export type getBankrollApiV1BetsBankrollGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}
    
export type getBankrollApiV1BetsBankrollGetResponseSuccess = (getBankrollApiV1BetsBankrollGetResponse200) & {
  headers: Headers;
};
export type getBankrollApiV1BetsBankrollGetResponseError = (getBankrollApiV1BetsBankrollGetResponse401) & {
  headers: Headers;
};

export type getBankrollApiV1BetsBankrollGetResponse = (getBankrollApiV1BetsBankrollGetResponseSuccess | getBankrollApiV1BetsBankrollGetResponseError)

export const getGetBankrollApiV1BetsBankrollGetUrl = () => {


  

  return `/api/v1/bets/bankroll`
}

export const getBankrollApiV1BetsBankrollGet = async ( options?: RequestInit): Promise<getBankrollApiV1BetsBankrollGetResponse> => {
  
  return customInstance<getBankrollApiV1BetsBankrollGetResponse>(getGetBankrollApiV1BetsBankrollGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetBankrollApiV1BetsBankrollGetQueryKey = () => {
    return [
    `/api/v1/bets/bankroll`
    ] as const;
    }

    
export const getGetBankrollApiV1BetsBankrollGetQueryOptions = <TData = Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError = HTTPErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBankrollApiV1BetsBankrollGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>> = ({ signal }) => getBankrollApiV1BetsBankrollGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBankrollApiV1BetsBankrollGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>>
export type GetBankrollApiV1BetsBankrollGetQueryError = HTTPErrorResponse


export function useGetBankrollApiV1BetsBankrollGet<TData = Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError = HTTPErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>,
          TError,
          Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBankrollApiV1BetsBankrollGet<TData = Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>,
          TError,
          Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBankrollApiV1BetsBankrollGet<TData = Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Bankroll
 */

export function useGetBankrollApiV1BetsBankrollGet<TData = Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBankrollApiV1BetsBankrollGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBankrollApiV1BetsBankrollGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update user's bankroll settings.
 * @summary Update Bankroll
 */
export type updateBankrollApiV1BetsBankrollPutResponse200 = {
  data: BankrollResponse
  status: 200
}

export type updateBankrollApiV1BetsBankrollPutResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type updateBankrollApiV1BetsBankrollPutResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type updateBankrollApiV1BetsBankrollPutResponseSuccess = (updateBankrollApiV1BetsBankrollPutResponse200) & {
  headers: Headers;
};
export type updateBankrollApiV1BetsBankrollPutResponseError = (updateBankrollApiV1BetsBankrollPutResponse401 | updateBankrollApiV1BetsBankrollPutResponse422) & {
  headers: Headers;
};

export type updateBankrollApiV1BetsBankrollPutResponse = (updateBankrollApiV1BetsBankrollPutResponseSuccess | updateBankrollApiV1BetsBankrollPutResponseError)

export const getUpdateBankrollApiV1BetsBankrollPutUrl = () => {


  

  return `/api/v1/bets/bankroll`
}

export const updateBankrollApiV1BetsBankrollPut = async (bankrollSettings: BankrollSettings, options?: RequestInit): Promise<updateBankrollApiV1BetsBankrollPutResponse> => {
  
  return customInstance<updateBankrollApiV1BetsBankrollPutResponse>(getUpdateBankrollApiV1BetsBankrollPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bankrollSettings,)
  }
);}




export const getUpdateBankrollApiV1BetsBankrollPutMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBankrollApiV1BetsBankrollPut>>, TError,{data: BankrollSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBankrollApiV1BetsBankrollPut>>, TError,{data: BankrollSettings}, TContext> => {

const mutationKey = ['updateBankrollApiV1BetsBankrollPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBankrollApiV1BetsBankrollPut>>, {data: BankrollSettings}> = (props) => {
          const {data} = props ?? {};

          return  updateBankrollApiV1BetsBankrollPut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBankrollApiV1BetsBankrollPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateBankrollApiV1BetsBankrollPut>>>
    export type UpdateBankrollApiV1BetsBankrollPutMutationBody = BankrollSettings
    export type UpdateBankrollApiV1BetsBankrollPutMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Update Bankroll
 */
export const useUpdateBankrollApiV1BetsBankrollPut = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBankrollApiV1BetsBankrollPut>>, TError,{data: BankrollSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBankrollApiV1BetsBankrollPut>>,
        TError,
        {data: BankrollSettings},
        TContext
      > => {
      return useMutation(getUpdateBankrollApiV1BetsBankrollPutMutationOptions(options), queryClient);
    }
    /**
 * List user's bets.
 * @summary List Bets
 */
export type listBetsApiV1BetsGetResponse200 = {
  data: BetResponse[]
  status: 200
}

export type listBetsApiV1BetsGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type listBetsApiV1BetsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type listBetsApiV1BetsGetResponseSuccess = (listBetsApiV1BetsGetResponse200) & {
  headers: Headers;
};
export type listBetsApiV1BetsGetResponseError = (listBetsApiV1BetsGetResponse401 | listBetsApiV1BetsGetResponse422) & {
  headers: Headers;
};

export type listBetsApiV1BetsGetResponse = (listBetsApiV1BetsGetResponseSuccess | listBetsApiV1BetsGetResponseError)

export const getListBetsApiV1BetsGetUrl = (params?: ListBetsApiV1BetsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/bets?${stringifiedParams}` : `/api/v1/bets`
}

export const listBetsApiV1BetsGet = async (params?: ListBetsApiV1BetsGetParams, options?: RequestInit): Promise<listBetsApiV1BetsGetResponse> => {
  
  return customInstance<listBetsApiV1BetsGetResponse>(getListBetsApiV1BetsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListBetsApiV1BetsGetQueryKey = (params?: ListBetsApiV1BetsGetParams,) => {
    return [
    `/api/v1/bets`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListBetsApiV1BetsGetQueryOptions = <TData = Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError = HTTPErrorResponse | HTTPValidationError>(params?: ListBetsApiV1BetsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBetsApiV1BetsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>> = ({ signal }) => listBetsApiV1BetsGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBetsApiV1BetsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>>
export type ListBetsApiV1BetsGetQueryError = HTTPErrorResponse | HTTPValidationError


export function useListBetsApiV1BetsGet<TData = Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: undefined |  ListBetsApiV1BetsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBetsApiV1BetsGet>>,
          TError,
          Awaited<ReturnType<typeof listBetsApiV1BetsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBetsApiV1BetsGet<TData = Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params?: ListBetsApiV1BetsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBetsApiV1BetsGet>>,
          TError,
          Awaited<ReturnType<typeof listBetsApiV1BetsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBetsApiV1BetsGet<TData = Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params?: ListBetsApiV1BetsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Bets
 */

export function useListBetsApiV1BetsGet<TData = Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params?: ListBetsApiV1BetsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBetsApiV1BetsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBetsApiV1BetsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Create a new bet.
 * @summary Create Bet
 */
export type createBetApiV1BetsPostResponse201 = {
  data: BetResponse
  status: 201
}

export type createBetApiV1BetsPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type createBetApiV1BetsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createBetApiV1BetsPostResponseSuccess = (createBetApiV1BetsPostResponse201) & {
  headers: Headers;
};
export type createBetApiV1BetsPostResponseError = (createBetApiV1BetsPostResponse401 | createBetApiV1BetsPostResponse422) & {
  headers: Headers;
};

export type createBetApiV1BetsPostResponse = (createBetApiV1BetsPostResponseSuccess | createBetApiV1BetsPostResponseError)

export const getCreateBetApiV1BetsPostUrl = () => {


  

  return `/api/v1/bets`
}

export const createBetApiV1BetsPost = async (betCreate: BetCreate, options?: RequestInit): Promise<createBetApiV1BetsPostResponse> => {
  
  return customInstance<createBetApiV1BetsPostResponse>(getCreateBetApiV1BetsPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      betCreate,)
  }
);}




export const getCreateBetApiV1BetsPostMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBetApiV1BetsPost>>, TError,{data: BetCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createBetApiV1BetsPost>>, TError,{data: BetCreate}, TContext> => {

const mutationKey = ['createBetApiV1BetsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBetApiV1BetsPost>>, {data: BetCreate}> = (props) => {
          const {data} = props ?? {};

          return  createBetApiV1BetsPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBetApiV1BetsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createBetApiV1BetsPost>>>
    export type CreateBetApiV1BetsPostMutationBody = BetCreate
    export type CreateBetApiV1BetsPostMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Create Bet
 */
export const useCreateBetApiV1BetsPost = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBetApiV1BetsPost>>, TError,{data: BetCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBetApiV1BetsPost>>,
        TError,
        {data: BetCreate},
        TContext
      > => {
      return useMutation(getCreateBetApiV1BetsPostMutationOptions(options), queryClient);
    }
    /**
 * Update bet status (won, lost, void).
 * @summary Update Bet
 */
export type updateBetApiV1BetsBetIdPatchResponse200 = {
  data: BetResponse
  status: 200
}

export type updateBetApiV1BetsBetIdPatchResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type updateBetApiV1BetsBetIdPatchResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type updateBetApiV1BetsBetIdPatchResponseSuccess = (updateBetApiV1BetsBetIdPatchResponse200) & {
  headers: Headers;
};
export type updateBetApiV1BetsBetIdPatchResponseError = (updateBetApiV1BetsBetIdPatchResponse401 | updateBetApiV1BetsBetIdPatchResponse422) & {
  headers: Headers;
};

export type updateBetApiV1BetsBetIdPatchResponse = (updateBetApiV1BetsBetIdPatchResponseSuccess | updateBetApiV1BetsBetIdPatchResponseError)

export const getUpdateBetApiV1BetsBetIdPatchUrl = (betId: number,) => {


  

  return `/api/v1/bets/${betId}`
}

export const updateBetApiV1BetsBetIdPatch = async (betId: number,
    betUpdate: BetUpdate, options?: RequestInit): Promise<updateBetApiV1BetsBetIdPatchResponse> => {
  
  return customInstance<updateBetApiV1BetsBetIdPatchResponse>(getUpdateBetApiV1BetsBetIdPatchUrl(betId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      betUpdate,)
  }
);}




export const getUpdateBetApiV1BetsBetIdPatchMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBetApiV1BetsBetIdPatch>>, TError,{betId: number;data: BetUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBetApiV1BetsBetIdPatch>>, TError,{betId: number;data: BetUpdate}, TContext> => {

const mutationKey = ['updateBetApiV1BetsBetIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBetApiV1BetsBetIdPatch>>, {betId: number;data: BetUpdate}> = (props) => {
          const {betId,data} = props ?? {};

          return  updateBetApiV1BetsBetIdPatch(betId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBetApiV1BetsBetIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBetApiV1BetsBetIdPatch>>>
    export type UpdateBetApiV1BetsBetIdPatchMutationBody = BetUpdate
    export type UpdateBetApiV1BetsBetIdPatchMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Update Bet
 */
export const useUpdateBetApiV1BetsBetIdPatch = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBetApiV1BetsBetIdPatch>>, TError,{betId: number;data: BetUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBetApiV1BetsBetIdPatch>>,
        TError,
        {betId: number;data: BetUpdate},
        TContext
      > => {
      return useMutation(getUpdateBetApiV1BetsBetIdPatchMutationOptions(options), queryClient);
    }
    /**
 * Delete a pending bet.
 * @summary Delete Bet
 */
export type deleteBetApiV1BetsBetIdDeleteResponse204 = {
  data: void
  status: 204
}

export type deleteBetApiV1BetsBetIdDeleteResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type deleteBetApiV1BetsBetIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type deleteBetApiV1BetsBetIdDeleteResponseSuccess = (deleteBetApiV1BetsBetIdDeleteResponse204) & {
  headers: Headers;
};
export type deleteBetApiV1BetsBetIdDeleteResponseError = (deleteBetApiV1BetsBetIdDeleteResponse401 | deleteBetApiV1BetsBetIdDeleteResponse422) & {
  headers: Headers;
};

export type deleteBetApiV1BetsBetIdDeleteResponse = (deleteBetApiV1BetsBetIdDeleteResponseSuccess | deleteBetApiV1BetsBetIdDeleteResponseError)

export const getDeleteBetApiV1BetsBetIdDeleteUrl = (betId: number,) => {


  

  return `/api/v1/bets/${betId}`
}

export const deleteBetApiV1BetsBetIdDelete = async (betId: number, options?: RequestInit): Promise<deleteBetApiV1BetsBetIdDeleteResponse> => {
  
  return customInstance<deleteBetApiV1BetsBetIdDeleteResponse>(getDeleteBetApiV1BetsBetIdDeleteUrl(betId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteBetApiV1BetsBetIdDeleteMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBetApiV1BetsBetIdDelete>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBetApiV1BetsBetIdDelete>>, TError,{betId: number}, TContext> => {

const mutationKey = ['deleteBetApiV1BetsBetIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBetApiV1BetsBetIdDelete>>, {betId: number}> = (props) => {
          const {betId} = props ?? {};

          return  deleteBetApiV1BetsBetIdDelete(betId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBetApiV1BetsBetIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBetApiV1BetsBetIdDelete>>>
    
    export type DeleteBetApiV1BetsBetIdDeleteMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Delete Bet
 */
export const useDeleteBetApiV1BetsBetIdDelete = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBetApiV1BetsBetIdDelete>>, TError,{betId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBetApiV1BetsBetIdDelete>>,
        TError,
        {betId: number},
        TContext
      > => {
      return useMutation(getDeleteBetApiV1BetsBetIdDeleteMutationOptions(options), queryClient);
    }
    /**
 * Calculate Kelly Criterion stake suggestion.

Kelly formula: f* = (bp - q) / b
Where:
- f* = fraction of bankroll to bet
- b = decimal odds - 1
- p = probability of winning
- q = probability of losing (1 - p)
 * @summary Get Kelly Suggestion
 */
export type getKellySuggestionApiV1BetsKellyGetResponse200 = {
  data: KellySuggestion
  status: 200
}

export type getKellySuggestionApiV1BetsKellyGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getKellySuggestionApiV1BetsKellyGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getKellySuggestionApiV1BetsKellyGetResponseSuccess = (getKellySuggestionApiV1BetsKellyGetResponse200) & {
  headers: Headers;
};
export type getKellySuggestionApiV1BetsKellyGetResponseError = (getKellySuggestionApiV1BetsKellyGetResponse401 | getKellySuggestionApiV1BetsKellyGetResponse422) & {
  headers: Headers;
};

export type getKellySuggestionApiV1BetsKellyGetResponse = (getKellySuggestionApiV1BetsKellyGetResponseSuccess | getKellySuggestionApiV1BetsKellyGetResponseError)

export const getGetKellySuggestionApiV1BetsKellyGetUrl = (params: GetKellySuggestionApiV1BetsKellyGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/bets/kelly?${stringifiedParams}` : `/api/v1/bets/kelly`
}

export const getKellySuggestionApiV1BetsKellyGet = async (params: GetKellySuggestionApiV1BetsKellyGetParams, options?: RequestInit): Promise<getKellySuggestionApiV1BetsKellyGetResponse> => {
  
  return customInstance<getKellySuggestionApiV1BetsKellyGetResponse>(getGetKellySuggestionApiV1BetsKellyGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetKellySuggestionApiV1BetsKellyGetQueryKey = (params?: GetKellySuggestionApiV1BetsKellyGetParams,) => {
    return [
    `/api/v1/bets/kelly`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetKellySuggestionApiV1BetsKellyGetQueryOptions = <TData = Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError = HTTPErrorResponse | HTTPValidationError>(params: GetKellySuggestionApiV1BetsKellyGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetKellySuggestionApiV1BetsKellyGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>> = ({ signal }) => getKellySuggestionApiV1BetsKellyGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetKellySuggestionApiV1BetsKellyGetQueryResult = NonNullable<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>>
export type GetKellySuggestionApiV1BetsKellyGetQueryError = HTTPErrorResponse | HTTPValidationError


export function useGetKellySuggestionApiV1BetsKellyGet<TData = Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetKellySuggestionApiV1BetsKellyGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>,
          TError,
          Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetKellySuggestionApiV1BetsKellyGet<TData = Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetKellySuggestionApiV1BetsKellyGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>,
          TError,
          Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetKellySuggestionApiV1BetsKellyGet<TData = Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetKellySuggestionApiV1BetsKellyGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Kelly Suggestion
 */

export function useGetKellySuggestionApiV1BetsKellyGet<TData = Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetKellySuggestionApiV1BetsKellyGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKellySuggestionApiV1BetsKellyGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetKellySuggestionApiV1BetsKellyGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




