/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * WinRate AI API
 * API de predictions de paris sportifs sur le football europeen
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CustomArticleRequest,
  GetMatchContextApiV1VectorMatchContextGet200,
  GetMatchContextApiV1VectorMatchContextGetParams,
  GetTeamContextApiV1VectorTeamContextGet200,
  GetTeamContextApiV1VectorTeamContextGetParams,
  HTTPErrorResponse,
  HTTPValidationError,
  IndexCustomArticleApiV1VectorIndexArticlePost200,
  IngestAllNewsApiV1VectorIngestAllPostParams,
  IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams,
  IngestTeamNewsApiV1VectorIngestTeamPostParams,
  IngestionResponse,
  SearchNewsApiV1VectorSearchGetParams,
  SearchResponse,
  VectorStoreStats
} from '../../models';

import { customInstance } from '../../custom-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get vector store statistics.

Returns information about the Qdrant collection including total vectors.
Admin role required.
 * @summary Get Vector Stats
 */
export type getVectorStatsApiV1VectorStatsGetResponse200 = {
  data: VectorStoreStats
  status: 200
}

export type getVectorStatsApiV1VectorStatsGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getVectorStatsApiV1VectorStatsGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type getVectorStatsApiV1VectorStatsGetResponseSuccess = (getVectorStatsApiV1VectorStatsGetResponse200) & {
  headers: Headers;
};
export type getVectorStatsApiV1VectorStatsGetResponseError = (getVectorStatsApiV1VectorStatsGetResponse401 | getVectorStatsApiV1VectorStatsGetResponse403) & {
  headers: Headers;
};

export type getVectorStatsApiV1VectorStatsGetResponse = (getVectorStatsApiV1VectorStatsGetResponseSuccess | getVectorStatsApiV1VectorStatsGetResponseError)

export const getGetVectorStatsApiV1VectorStatsGetUrl = () => {


  

  return `/api/v1/vector/stats`
}

export const getVectorStatsApiV1VectorStatsGet = async ( options?: RequestInit): Promise<getVectorStatsApiV1VectorStatsGetResponse> => {
  
  return customInstance<getVectorStatsApiV1VectorStatsGetResponse>(getGetVectorStatsApiV1VectorStatsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetVectorStatsApiV1VectorStatsGetQueryKey = () => {
    return [
    `/api/v1/vector/stats`
    ] as const;
    }

    
export const getGetVectorStatsApiV1VectorStatsGetQueryOptions = <TData = Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError = HTTPErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetVectorStatsApiV1VectorStatsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>> = ({ signal }) => getVectorStatsApiV1VectorStatsGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetVectorStatsApiV1VectorStatsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>>
export type GetVectorStatsApiV1VectorStatsGetQueryError = HTTPErrorResponse


export function useGetVectorStatsApiV1VectorStatsGet<TData = Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError = HTTPErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVectorStatsApiV1VectorStatsGet<TData = Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetVectorStatsApiV1VectorStatsGet<TData = Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Vector Stats
 */

export function useGetVectorStatsApiV1VectorStatsGet<TData = Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getVectorStatsApiV1VectorStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetVectorStatsApiV1VectorStatsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Ingest news for a specific team.

Fetches news articles and indexes them in the vector store.
Admin role required.
 * @summary Ingest Team News
 */
export type ingestTeamNewsApiV1VectorIngestTeamPostResponse200 = {
  data: IngestionResponse
  status: 200
}

export type ingestTeamNewsApiV1VectorIngestTeamPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type ingestTeamNewsApiV1VectorIngestTeamPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}

export type ingestTeamNewsApiV1VectorIngestTeamPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type ingestTeamNewsApiV1VectorIngestTeamPostResponseSuccess = (ingestTeamNewsApiV1VectorIngestTeamPostResponse200) & {
  headers: Headers;
};
export type ingestTeamNewsApiV1VectorIngestTeamPostResponseError = (ingestTeamNewsApiV1VectorIngestTeamPostResponse401 | ingestTeamNewsApiV1VectorIngestTeamPostResponse403 | ingestTeamNewsApiV1VectorIngestTeamPostResponse422) & {
  headers: Headers;
};

export type ingestTeamNewsApiV1VectorIngestTeamPostResponse = (ingestTeamNewsApiV1VectorIngestTeamPostResponseSuccess | ingestTeamNewsApiV1VectorIngestTeamPostResponseError)

export const getIngestTeamNewsApiV1VectorIngestTeamPostUrl = (params: IngestTeamNewsApiV1VectorIngestTeamPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vector/ingest/team?${stringifiedParams}` : `/api/v1/vector/ingest/team`
}

export const ingestTeamNewsApiV1VectorIngestTeamPost = async (params: IngestTeamNewsApiV1VectorIngestTeamPostParams, options?: RequestInit): Promise<ingestTeamNewsApiV1VectorIngestTeamPostResponse> => {
  
  return customInstance<ingestTeamNewsApiV1VectorIngestTeamPostResponse>(getIngestTeamNewsApiV1VectorIngestTeamPostUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getIngestTeamNewsApiV1VectorIngestTeamPostMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestTeamNewsApiV1VectorIngestTeamPost>>, TError,{params: IngestTeamNewsApiV1VectorIngestTeamPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ingestTeamNewsApiV1VectorIngestTeamPost>>, TError,{params: IngestTeamNewsApiV1VectorIngestTeamPostParams}, TContext> => {

const mutationKey = ['ingestTeamNewsApiV1VectorIngestTeamPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingestTeamNewsApiV1VectorIngestTeamPost>>, {params: IngestTeamNewsApiV1VectorIngestTeamPostParams}> = (props) => {
          const {params} = props ?? {};

          return  ingestTeamNewsApiV1VectorIngestTeamPost(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IngestTeamNewsApiV1VectorIngestTeamPostMutationResult = NonNullable<Awaited<ReturnType<typeof ingestTeamNewsApiV1VectorIngestTeamPost>>>
    
    export type IngestTeamNewsApiV1VectorIngestTeamPostMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Ingest Team News
 */
export const useIngestTeamNewsApiV1VectorIngestTeamPost = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestTeamNewsApiV1VectorIngestTeamPost>>, TError,{params: IngestTeamNewsApiV1VectorIngestTeamPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingestTeamNewsApiV1VectorIngestTeamPost>>,
        TError,
        {params: IngestTeamNewsApiV1VectorIngestTeamPostParams},
        TContext
      > => {
      return useMutation(getIngestTeamNewsApiV1VectorIngestTeamPostMutationOptions(options), queryClient);
    }
    /**
 * Ingest news for all teams in a competition.

Admin role required.
 * @summary Ingest Competition News
 */
export type ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse200 = {
  data: IngestionResponse
  status: 200
}

export type ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}

export type ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponseSuccess = (ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse200) & {
  headers: Headers;
};
export type ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponseError = (ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse401 | ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse403 | ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse422) & {
  headers: Headers;
};

export type ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse = (ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponseSuccess | ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponseError)

export const getIngestCompetitionNewsApiV1VectorIngestCompetitionPostUrl = (params: IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vector/ingest/competition?${stringifiedParams}` : `/api/v1/vector/ingest/competition`
}

export const ingestCompetitionNewsApiV1VectorIngestCompetitionPost = async (params: IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams, options?: RequestInit): Promise<ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse> => {
  
  return customInstance<ingestCompetitionNewsApiV1VectorIngestCompetitionPostResponse>(getIngestCompetitionNewsApiV1VectorIngestCompetitionPostUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getIngestCompetitionNewsApiV1VectorIngestCompetitionPostMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestCompetitionNewsApiV1VectorIngestCompetitionPost>>, TError,{params: IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ingestCompetitionNewsApiV1VectorIngestCompetitionPost>>, TError,{params: IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams}, TContext> => {

const mutationKey = ['ingestCompetitionNewsApiV1VectorIngestCompetitionPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingestCompetitionNewsApiV1VectorIngestCompetitionPost>>, {params: IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams}> = (props) => {
          const {params} = props ?? {};

          return  ingestCompetitionNewsApiV1VectorIngestCompetitionPost(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IngestCompetitionNewsApiV1VectorIngestCompetitionPostMutationResult = NonNullable<Awaited<ReturnType<typeof ingestCompetitionNewsApiV1VectorIngestCompetitionPost>>>
    
    export type IngestCompetitionNewsApiV1VectorIngestCompetitionPostMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Ingest Competition News
 */
export const useIngestCompetitionNewsApiV1VectorIngestCompetitionPost = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestCompetitionNewsApiV1VectorIngestCompetitionPost>>, TError,{params: IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingestCompetitionNewsApiV1VectorIngestCompetitionPost>>,
        TError,
        {params: IngestCompetitionNewsApiV1VectorIngestCompetitionPostParams},
        TContext
      > => {
      return useMutation(getIngestCompetitionNewsApiV1VectorIngestCompetitionPostMutationOptions(options), queryClient);
    }
    /**
 * Ingest news for all supported competitions.

This can take several minutes to complete.
Admin role required.
 * @summary Ingest All News
 */
export type ingestAllNewsApiV1VectorIngestAllPostResponse200 = {
  data: IngestionResponse
  status: 200
}

export type ingestAllNewsApiV1VectorIngestAllPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type ingestAllNewsApiV1VectorIngestAllPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}

export type ingestAllNewsApiV1VectorIngestAllPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type ingestAllNewsApiV1VectorIngestAllPostResponseSuccess = (ingestAllNewsApiV1VectorIngestAllPostResponse200) & {
  headers: Headers;
};
export type ingestAllNewsApiV1VectorIngestAllPostResponseError = (ingestAllNewsApiV1VectorIngestAllPostResponse401 | ingestAllNewsApiV1VectorIngestAllPostResponse403 | ingestAllNewsApiV1VectorIngestAllPostResponse422) & {
  headers: Headers;
};

export type ingestAllNewsApiV1VectorIngestAllPostResponse = (ingestAllNewsApiV1VectorIngestAllPostResponseSuccess | ingestAllNewsApiV1VectorIngestAllPostResponseError)

export const getIngestAllNewsApiV1VectorIngestAllPostUrl = (params?: IngestAllNewsApiV1VectorIngestAllPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vector/ingest/all?${stringifiedParams}` : `/api/v1/vector/ingest/all`
}

export const ingestAllNewsApiV1VectorIngestAllPost = async (params?: IngestAllNewsApiV1VectorIngestAllPostParams, options?: RequestInit): Promise<ingestAllNewsApiV1VectorIngestAllPostResponse> => {
  
  return customInstance<ingestAllNewsApiV1VectorIngestAllPostResponse>(getIngestAllNewsApiV1VectorIngestAllPostUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getIngestAllNewsApiV1VectorIngestAllPostMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestAllNewsApiV1VectorIngestAllPost>>, TError,{params?: IngestAllNewsApiV1VectorIngestAllPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ingestAllNewsApiV1VectorIngestAllPost>>, TError,{params?: IngestAllNewsApiV1VectorIngestAllPostParams}, TContext> => {

const mutationKey = ['ingestAllNewsApiV1VectorIngestAllPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingestAllNewsApiV1VectorIngestAllPost>>, {params?: IngestAllNewsApiV1VectorIngestAllPostParams}> = (props) => {
          const {params} = props ?? {};

          return  ingestAllNewsApiV1VectorIngestAllPost(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IngestAllNewsApiV1VectorIngestAllPostMutationResult = NonNullable<Awaited<ReturnType<typeof ingestAllNewsApiV1VectorIngestAllPost>>>
    
    export type IngestAllNewsApiV1VectorIngestAllPostMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Ingest All News
 */
export const useIngestAllNewsApiV1VectorIngestAllPost = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingestAllNewsApiV1VectorIngestAllPost>>, TError,{params?: IngestAllNewsApiV1VectorIngestAllPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingestAllNewsApiV1VectorIngestAllPost>>,
        TError,
        {params?: IngestAllNewsApiV1VectorIngestAllPostParams},
        TContext
      > => {
      return useMutation(getIngestAllNewsApiV1VectorIngestAllPostMutationOptions(options), queryClient);
    }
    /**
 * Index a custom article manually.

Useful for adding breaking news or important updates.
Admin role required.
 * @summary Index Custom Article
 */
export type indexCustomArticleApiV1VectorIndexArticlePostResponse200 = {
  data: IndexCustomArticleApiV1VectorIndexArticlePost200
  status: 200
}

export type indexCustomArticleApiV1VectorIndexArticlePostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type indexCustomArticleApiV1VectorIndexArticlePostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}

export type indexCustomArticleApiV1VectorIndexArticlePostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type indexCustomArticleApiV1VectorIndexArticlePostResponseSuccess = (indexCustomArticleApiV1VectorIndexArticlePostResponse200) & {
  headers: Headers;
};
export type indexCustomArticleApiV1VectorIndexArticlePostResponseError = (indexCustomArticleApiV1VectorIndexArticlePostResponse401 | indexCustomArticleApiV1VectorIndexArticlePostResponse403 | indexCustomArticleApiV1VectorIndexArticlePostResponse422) & {
  headers: Headers;
};

export type indexCustomArticleApiV1VectorIndexArticlePostResponse = (indexCustomArticleApiV1VectorIndexArticlePostResponseSuccess | indexCustomArticleApiV1VectorIndexArticlePostResponseError)

export const getIndexCustomArticleApiV1VectorIndexArticlePostUrl = () => {


  

  return `/api/v1/vector/index/article`
}

export const indexCustomArticleApiV1VectorIndexArticlePost = async (customArticleRequest: CustomArticleRequest, options?: RequestInit): Promise<indexCustomArticleApiV1VectorIndexArticlePostResponse> => {
  
  return customInstance<indexCustomArticleApiV1VectorIndexArticlePostResponse>(getIndexCustomArticleApiV1VectorIndexArticlePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customArticleRequest,)
  }
);}




export const getIndexCustomArticleApiV1VectorIndexArticlePostMutationOptions = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof indexCustomArticleApiV1VectorIndexArticlePost>>, TError,{data: CustomArticleRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof indexCustomArticleApiV1VectorIndexArticlePost>>, TError,{data: CustomArticleRequest}, TContext> => {

const mutationKey = ['indexCustomArticleApiV1VectorIndexArticlePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof indexCustomArticleApiV1VectorIndexArticlePost>>, {data: CustomArticleRequest}> = (props) => {
          const {data} = props ?? {};

          return  indexCustomArticleApiV1VectorIndexArticlePost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IndexCustomArticleApiV1VectorIndexArticlePostMutationResult = NonNullable<Awaited<ReturnType<typeof indexCustomArticleApiV1VectorIndexArticlePost>>>
    export type IndexCustomArticleApiV1VectorIndexArticlePostMutationBody = CustomArticleRequest
    export type IndexCustomArticleApiV1VectorIndexArticlePostMutationError = HTTPErrorResponse | HTTPValidationError

    /**
 * @summary Index Custom Article
 */
export const useIndexCustomArticleApiV1VectorIndexArticlePost = <TError = HTTPErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof indexCustomArticleApiV1VectorIndexArticlePost>>, TError,{data: CustomArticleRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof indexCustomArticleApiV1VectorIndexArticlePost>>,
        TError,
        {data: CustomArticleRequest},
        TContext
      > => {
      return useMutation(getIndexCustomArticleApiV1VectorIndexArticlePostMutationOptions(options), queryClient);
    }
    /**
 * Search news articles using semantic search.

Premium feature - uses vector embeddings for semantic matching.
 * @summary Search News
 */
export type searchNewsApiV1VectorSearchGetResponse200 = {
  data: SearchResponse
  status: 200
}

export type searchNewsApiV1VectorSearchGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type searchNewsApiV1VectorSearchGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}

export type searchNewsApiV1VectorSearchGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type searchNewsApiV1VectorSearchGetResponseSuccess = (searchNewsApiV1VectorSearchGetResponse200) & {
  headers: Headers;
};
export type searchNewsApiV1VectorSearchGetResponseError = (searchNewsApiV1VectorSearchGetResponse401 | searchNewsApiV1VectorSearchGetResponse403 | searchNewsApiV1VectorSearchGetResponse422) & {
  headers: Headers;
};

export type searchNewsApiV1VectorSearchGetResponse = (searchNewsApiV1VectorSearchGetResponseSuccess | searchNewsApiV1VectorSearchGetResponseError)

export const getSearchNewsApiV1VectorSearchGetUrl = (params: SearchNewsApiV1VectorSearchGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vector/search?${stringifiedParams}` : `/api/v1/vector/search`
}

export const searchNewsApiV1VectorSearchGet = async (params: SearchNewsApiV1VectorSearchGetParams, options?: RequestInit): Promise<searchNewsApiV1VectorSearchGetResponse> => {
  
  return customInstance<searchNewsApiV1VectorSearchGetResponse>(getSearchNewsApiV1VectorSearchGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getSearchNewsApiV1VectorSearchGetQueryKey = (params?: SearchNewsApiV1VectorSearchGetParams,) => {
    return [
    `/api/v1/vector/search`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getSearchNewsApiV1VectorSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError = HTTPErrorResponse | HTTPValidationError>(params: SearchNewsApiV1VectorSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchNewsApiV1VectorSearchGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>> = ({ signal }) => searchNewsApiV1VectorSearchGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchNewsApiV1VectorSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>>
export type SearchNewsApiV1VectorSearchGetQueryError = HTTPErrorResponse | HTTPValidationError


export function useSearchNewsApiV1VectorSearchGet<TData = Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: SearchNewsApiV1VectorSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchNewsApiV1VectorSearchGet<TData = Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: SearchNewsApiV1VectorSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchNewsApiV1VectorSearchGet<TData = Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: SearchNewsApiV1VectorSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search News
 */

export function useSearchNewsApiV1VectorSearchGet<TData = Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: SearchNewsApiV1VectorSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNewsApiV1VectorSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchNewsApiV1VectorSearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get comprehensive context for a team.

Returns categorized news (injuries, transfers, form, etc.).
Premium feature.
 * @summary Get Team Context
 */
export type getTeamContextApiV1VectorTeamContextGetResponse200 = {
  data: GetTeamContextApiV1VectorTeamContextGet200
  status: 200
}

export type getTeamContextApiV1VectorTeamContextGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getTeamContextApiV1VectorTeamContextGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}

export type getTeamContextApiV1VectorTeamContextGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getTeamContextApiV1VectorTeamContextGetResponseSuccess = (getTeamContextApiV1VectorTeamContextGetResponse200) & {
  headers: Headers;
};
export type getTeamContextApiV1VectorTeamContextGetResponseError = (getTeamContextApiV1VectorTeamContextGetResponse401 | getTeamContextApiV1VectorTeamContextGetResponse403 | getTeamContextApiV1VectorTeamContextGetResponse422) & {
  headers: Headers;
};

export type getTeamContextApiV1VectorTeamContextGetResponse = (getTeamContextApiV1VectorTeamContextGetResponseSuccess | getTeamContextApiV1VectorTeamContextGetResponseError)

export const getGetTeamContextApiV1VectorTeamContextGetUrl = (params: GetTeamContextApiV1VectorTeamContextGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vector/team-context?${stringifiedParams}` : `/api/v1/vector/team-context`
}

export const getTeamContextApiV1VectorTeamContextGet = async (params: GetTeamContextApiV1VectorTeamContextGetParams, options?: RequestInit): Promise<getTeamContextApiV1VectorTeamContextGetResponse> => {
  
  return customInstance<getTeamContextApiV1VectorTeamContextGetResponse>(getGetTeamContextApiV1VectorTeamContextGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTeamContextApiV1VectorTeamContextGetQueryKey = (params?: GetTeamContextApiV1VectorTeamContextGetParams,) => {
    return [
    `/api/v1/vector/team-context`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetTeamContextApiV1VectorTeamContextGetQueryOptions = <TData = Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(params: GetTeamContextApiV1VectorTeamContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTeamContextApiV1VectorTeamContextGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>> = ({ signal }) => getTeamContextApiV1VectorTeamContextGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTeamContextApiV1VectorTeamContextGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>>
export type GetTeamContextApiV1VectorTeamContextGetQueryError = HTTPErrorResponse | HTTPValidationError


export function useGetTeamContextApiV1VectorTeamContextGet<TData = Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetTeamContextApiV1VectorTeamContextGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTeamContextApiV1VectorTeamContextGet<TData = Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetTeamContextApiV1VectorTeamContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>,
          TError,
          Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTeamContextApiV1VectorTeamContextGet<TData = Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetTeamContextApiV1VectorTeamContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Team Context
 */

export function useGetTeamContextApiV1VectorTeamContextGet<TData = Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetTeamContextApiV1VectorTeamContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTeamContextApiV1VectorTeamContextGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTeamContextApiV1VectorTeamContextGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get semantic context for a match.

Retrieves relevant news for both teams using vector search.
Premium feature.
 * @summary Get Match Context
 */
export type getMatchContextApiV1VectorMatchContextGetResponse200 = {
  data: GetMatchContextApiV1VectorMatchContextGet200
  status: 200
}

export type getMatchContextApiV1VectorMatchContextGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getMatchContextApiV1VectorMatchContextGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}

export type getMatchContextApiV1VectorMatchContextGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getMatchContextApiV1VectorMatchContextGetResponseSuccess = (getMatchContextApiV1VectorMatchContextGetResponse200) & {
  headers: Headers;
};
export type getMatchContextApiV1VectorMatchContextGetResponseError = (getMatchContextApiV1VectorMatchContextGetResponse401 | getMatchContextApiV1VectorMatchContextGetResponse403 | getMatchContextApiV1VectorMatchContextGetResponse422) & {
  headers: Headers;
};

export type getMatchContextApiV1VectorMatchContextGetResponse = (getMatchContextApiV1VectorMatchContextGetResponseSuccess | getMatchContextApiV1VectorMatchContextGetResponseError)

export const getGetMatchContextApiV1VectorMatchContextGetUrl = (params: GetMatchContextApiV1VectorMatchContextGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vector/match-context?${stringifiedParams}` : `/api/v1/vector/match-context`
}

export const getMatchContextApiV1VectorMatchContextGet = async (params: GetMatchContextApiV1VectorMatchContextGetParams, options?: RequestInit): Promise<getMatchContextApiV1VectorMatchContextGetResponse> => {
  
  return customInstance<getMatchContextApiV1VectorMatchContextGetResponse>(getGetMatchContextApiV1VectorMatchContextGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMatchContextApiV1VectorMatchContextGetQueryKey = (params?: GetMatchContextApiV1VectorMatchContextGetParams,) => {
    return [
    `/api/v1/vector/match-context`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetMatchContextApiV1VectorMatchContextGetQueryOptions = <TData = Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(params: GetMatchContextApiV1VectorMatchContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMatchContextApiV1VectorMatchContextGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>> = ({ signal }) => getMatchContextApiV1VectorMatchContextGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMatchContextApiV1VectorMatchContextGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>>
export type GetMatchContextApiV1VectorMatchContextGetQueryError = HTTPErrorResponse | HTTPValidationError


export function useGetMatchContextApiV1VectorMatchContextGet<TData = Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetMatchContextApiV1VectorMatchContextGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>,
          TError,
          Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMatchContextApiV1VectorMatchContextGet<TData = Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetMatchContextApiV1VectorMatchContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>,
          TError,
          Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMatchContextApiV1VectorMatchContextGet<TData = Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetMatchContextApiV1VectorMatchContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Match Context
 */

export function useGetMatchContextApiV1VectorMatchContextGet<TData = Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError = HTTPErrorResponse | HTTPValidationError>(
 params: GetMatchContextApiV1VectorMatchContextGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMatchContextApiV1VectorMatchContextGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMatchContextApiV1VectorMatchContextGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




