/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Paris Sportif API
 * API de predictions de paris sportifs sur le football europeen
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPErrorResponse,
  MLStatusResponse,
  PipelineResponse
} from '../../models';

import { customInstance } from '../../custom-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get current ML system status.

Returns information about:
- Whether models are trained and available
- Age of training data
- Feature engineering state
 * @summary Get Ml Status
 */
export type getMlStatusApiV1MlStatusGetResponse200 = {
  data: MLStatusResponse
  status: 200
}

export type getMlStatusApiV1MlStatusGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getMlStatusApiV1MlStatusGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type getMlStatusApiV1MlStatusGetResponseSuccess = (getMlStatusApiV1MlStatusGetResponse200) & {
  headers: Headers;
};
export type getMlStatusApiV1MlStatusGetResponseError = (getMlStatusApiV1MlStatusGetResponse401 | getMlStatusApiV1MlStatusGetResponse403) & {
  headers: Headers;
};

export type getMlStatusApiV1MlStatusGetResponse = (getMlStatusApiV1MlStatusGetResponseSuccess | getMlStatusApiV1MlStatusGetResponseError)

export const getGetMlStatusApiV1MlStatusGetUrl = () => {


  

  return `/api/v1/ml/status`
}

export const getMlStatusApiV1MlStatusGet = async ( options?: RequestInit): Promise<getMlStatusApiV1MlStatusGetResponse> => {
  
  return customInstance<getMlStatusApiV1MlStatusGetResponse>(getGetMlStatusApiV1MlStatusGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMlStatusApiV1MlStatusGetQueryKey = () => {
    return [
    `/api/v1/ml/status`
    ] as const;
    }

    
export const getGetMlStatusApiV1MlStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMlStatusApiV1MlStatusGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>> = ({ signal }) => getMlStatusApiV1MlStatusGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMlStatusApiV1MlStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>>
export type GetMlStatusApiV1MlStatusGetQueryError = HTTPErrorResponse


export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Ml Status
 */

export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMlStatusApiV1MlStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Start data collection in background.

Collects historical match data from football-data.org API.
This is a long-running task that runs in the background.
 * @summary Collect Data
 */
export type collectDataApiV1MlCollectPostResponse200 = {
  data: PipelineResponse
  status: 200
}

export type collectDataApiV1MlCollectPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type collectDataApiV1MlCollectPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type collectDataApiV1MlCollectPostResponseSuccess = (collectDataApiV1MlCollectPostResponse200) & {
  headers: Headers;
};
export type collectDataApiV1MlCollectPostResponseError = (collectDataApiV1MlCollectPostResponse401 | collectDataApiV1MlCollectPostResponse403) & {
  headers: Headers;
};

export type collectDataApiV1MlCollectPostResponse = (collectDataApiV1MlCollectPostResponseSuccess | collectDataApiV1MlCollectPostResponseError)

export const getCollectDataApiV1MlCollectPostUrl = () => {


  

  return `/api/v1/ml/collect`
}

export const collectDataApiV1MlCollectPost = async ( options?: RequestInit): Promise<collectDataApiV1MlCollectPostResponse> => {
  
  return customInstance<collectDataApiV1MlCollectPostResponse>(getCollectDataApiV1MlCollectPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getCollectDataApiV1MlCollectPostMutationOptions = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, TError,void, TContext> => {

const mutationKey = ['collectDataApiV1MlCollectPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, void> = () => {
          

          return  collectDataApiV1MlCollectPost(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CollectDataApiV1MlCollectPostMutationResult = NonNullable<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>>
    
    export type CollectDataApiV1MlCollectPostMutationError = HTTPErrorResponse

    /**
 * @summary Collect Data
 */
export const useCollectDataApiV1MlCollectPost = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getCollectDataApiV1MlCollectPostMutationOptions(options), queryClient);
    }
    /**
 * Start model training in background.

Trains XGBoost and Random Forest models on collected data.
Requires data to be collected first.
 * @summary Train Models
 */
export type trainModelsApiV1MlTrainPostResponse200 = {
  data: PipelineResponse
  status: 200
}

export type trainModelsApiV1MlTrainPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type trainModelsApiV1MlTrainPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type trainModelsApiV1MlTrainPostResponseSuccess = (trainModelsApiV1MlTrainPostResponse200) & {
  headers: Headers;
};
export type trainModelsApiV1MlTrainPostResponseError = (trainModelsApiV1MlTrainPostResponse401 | trainModelsApiV1MlTrainPostResponse403) & {
  headers: Headers;
};

export type trainModelsApiV1MlTrainPostResponse = (trainModelsApiV1MlTrainPostResponseSuccess | trainModelsApiV1MlTrainPostResponseError)

export const getTrainModelsApiV1MlTrainPostUrl = () => {


  

  return `/api/v1/ml/train`
}

export const trainModelsApiV1MlTrainPost = async ( options?: RequestInit): Promise<trainModelsApiV1MlTrainPostResponse> => {
  
  return customInstance<trainModelsApiV1MlTrainPostResponse>(getTrainModelsApiV1MlTrainPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getTrainModelsApiV1MlTrainPostMutationOptions = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, TError,void, TContext> => {

const mutationKey = ['trainModelsApiV1MlTrainPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, void> = () => {
          

          return  trainModelsApiV1MlTrainPost(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TrainModelsApiV1MlTrainPostMutationResult = NonNullable<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>>
    
    export type TrainModelsApiV1MlTrainPostMutationError = HTTPErrorResponse

    /**
 * @summary Train Models
 */
export const useTrainModelsApiV1MlTrainPost = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getTrainModelsApiV1MlTrainPostMutationOptions(options), queryClient);
    }
    /**
 * Run full ML pipeline in background.

Executes:
1. Data collection from API
2. Model training on collected data
3. Model reloading for inference

This is a long-running task (5-15 minutes depending on API rate limits).
 * @summary Run Full Pipeline
 */
export type runFullPipelineApiV1MlRunFullPostResponse200 = {
  data: PipelineResponse
  status: 200
}

export type runFullPipelineApiV1MlRunFullPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type runFullPipelineApiV1MlRunFullPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type runFullPipelineApiV1MlRunFullPostResponseSuccess = (runFullPipelineApiV1MlRunFullPostResponse200) & {
  headers: Headers;
};
export type runFullPipelineApiV1MlRunFullPostResponseError = (runFullPipelineApiV1MlRunFullPostResponse401 | runFullPipelineApiV1MlRunFullPostResponse403) & {
  headers: Headers;
};

export type runFullPipelineApiV1MlRunFullPostResponse = (runFullPipelineApiV1MlRunFullPostResponseSuccess | runFullPipelineApiV1MlRunFullPostResponseError)

export const getRunFullPipelineApiV1MlRunFullPostUrl = () => {


  

  return `/api/v1/ml/run-full`
}

export const runFullPipelineApiV1MlRunFullPost = async ( options?: RequestInit): Promise<runFullPipelineApiV1MlRunFullPostResponse> => {
  
  return customInstance<runFullPipelineApiV1MlRunFullPostResponse>(getRunFullPipelineApiV1MlRunFullPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getRunFullPipelineApiV1MlRunFullPostMutationOptions = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, TError,void, TContext> => {

const mutationKey = ['runFullPipelineApiV1MlRunFullPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, void> = () => {
          

          return  runFullPipelineApiV1MlRunFullPost(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RunFullPipelineApiV1MlRunFullPostMutationResult = NonNullable<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>>
    
    export type RunFullPipelineApiV1MlRunFullPostMutationError = HTTPErrorResponse

    /**
 * @summary Run Full Pipeline
 */
export const useRunFullPipelineApiV1MlRunFullPost = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getRunFullPipelineApiV1MlRunFullPostMutationOptions(options), queryClient);
    }
    /**
 * Get current pipeline execution status.

Returns whether a pipeline task is running and the result of the last run.
 * @summary Get Pipeline Status
 */
export type getPipelineStatusApiV1MlPipelineStatusGetResponse200 = {
  data: PipelineResponse
  status: 200
}

export type getPipelineStatusApiV1MlPipelineStatusGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getPipelineStatusApiV1MlPipelineStatusGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type getPipelineStatusApiV1MlPipelineStatusGetResponseSuccess = (getPipelineStatusApiV1MlPipelineStatusGetResponse200) & {
  headers: Headers;
};
export type getPipelineStatusApiV1MlPipelineStatusGetResponseError = (getPipelineStatusApiV1MlPipelineStatusGetResponse401 | getPipelineStatusApiV1MlPipelineStatusGetResponse403) & {
  headers: Headers;
};

export type getPipelineStatusApiV1MlPipelineStatusGetResponse = (getPipelineStatusApiV1MlPipelineStatusGetResponseSuccess | getPipelineStatusApiV1MlPipelineStatusGetResponseError)

export const getGetPipelineStatusApiV1MlPipelineStatusGetUrl = () => {


  

  return `/api/v1/ml/pipeline-status`
}

export const getPipelineStatusApiV1MlPipelineStatusGet = async ( options?: RequestInit): Promise<getPipelineStatusApiV1MlPipelineStatusGetResponse> => {
  
  return customInstance<getPipelineStatusApiV1MlPipelineStatusGetResponse>(getGetPipelineStatusApiV1MlPipelineStatusGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPipelineStatusApiV1MlPipelineStatusGetQueryKey = () => {
    return [
    `/api/v1/ml/pipeline-status`
    ] as const;
    }

    
export const getGetPipelineStatusApiV1MlPipelineStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPipelineStatusApiV1MlPipelineStatusGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>> = ({ signal }) => getPipelineStatusApiV1MlPipelineStatusGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPipelineStatusApiV1MlPipelineStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>>
export type GetPipelineStatusApiV1MlPipelineStatusGetQueryError = HTTPErrorResponse


export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Pipeline Status
 */

export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPipelineStatusApiV1MlPipelineStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




