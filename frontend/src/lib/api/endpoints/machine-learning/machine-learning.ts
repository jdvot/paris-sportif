/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * WinRate AI API
 * API de predictions de paris sportifs sur le football europeen
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetTrainingDataApiV1MlTrainingDataGetParams,
  HFTrainingResponse,
  HTTPErrorResponse,
  HTTPValidationError,
  MLStatusResponse,
  PipelineResponse,
  TrainingDataResponse
} from '../../models';

import { customInstance } from '../../custom-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get current ML system status.

Checks HuggingFace ML service (remote) instead of local models
to avoid OOM on 512MB Render.
 * @summary Get Ml Status
 */
export type getMlStatusApiV1MlStatusGetResponse200 = {
  data: MLStatusResponse
  status: 200
}

export type getMlStatusApiV1MlStatusGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getMlStatusApiV1MlStatusGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type getMlStatusApiV1MlStatusGetResponseSuccess = (getMlStatusApiV1MlStatusGetResponse200) & {
  headers: Headers;
};
export type getMlStatusApiV1MlStatusGetResponseError = (getMlStatusApiV1MlStatusGetResponse401 | getMlStatusApiV1MlStatusGetResponse403) & {
  headers: Headers;
};

export type getMlStatusApiV1MlStatusGetResponse = (getMlStatusApiV1MlStatusGetResponseSuccess | getMlStatusApiV1MlStatusGetResponseError)

export const getGetMlStatusApiV1MlStatusGetUrl = () => {


  

  return `/api/v1/ml/status`
}

export const getMlStatusApiV1MlStatusGet = async ( options?: RequestInit): Promise<getMlStatusApiV1MlStatusGetResponse> => {
  
  return customInstance<getMlStatusApiV1MlStatusGetResponse>(getGetMlStatusApiV1MlStatusGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMlStatusApiV1MlStatusGetQueryKey = () => {
    return [
    `/api/v1/ml/status`
    ] as const;
    }

    
export const getGetMlStatusApiV1MlStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMlStatusApiV1MlStatusGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>> = ({ signal }) => getMlStatusApiV1MlStatusGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMlStatusApiV1MlStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>>
export type GetMlStatusApiV1MlStatusGetQueryError = HTTPErrorResponse


export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Ml Status
 */

export function useGetMlStatusApiV1MlStatusGet<TData = Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMlStatusApiV1MlStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMlStatusApiV1MlStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Start data collection in background.

Collects historical match data from football-data.org API.
This is a long-running task that runs in the background.
 * @summary Collect Data
 */
export type collectDataApiV1MlCollectPostResponse200 = {
  data: PipelineResponse
  status: 200
}

export type collectDataApiV1MlCollectPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type collectDataApiV1MlCollectPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type collectDataApiV1MlCollectPostResponseSuccess = (collectDataApiV1MlCollectPostResponse200) & {
  headers: Headers;
};
export type collectDataApiV1MlCollectPostResponseError = (collectDataApiV1MlCollectPostResponse401 | collectDataApiV1MlCollectPostResponse403) & {
  headers: Headers;
};

export type collectDataApiV1MlCollectPostResponse = (collectDataApiV1MlCollectPostResponseSuccess | collectDataApiV1MlCollectPostResponseError)

export const getCollectDataApiV1MlCollectPostUrl = () => {


  

  return `/api/v1/ml/collect`
}

export const collectDataApiV1MlCollectPost = async ( options?: RequestInit): Promise<collectDataApiV1MlCollectPostResponse> => {
  
  return customInstance<collectDataApiV1MlCollectPostResponse>(getCollectDataApiV1MlCollectPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getCollectDataApiV1MlCollectPostMutationOptions = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, TError,void, TContext> => {

const mutationKey = ['collectDataApiV1MlCollectPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, void> = () => {
          

          return  collectDataApiV1MlCollectPost(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CollectDataApiV1MlCollectPostMutationResult = NonNullable<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>>
    
    export type CollectDataApiV1MlCollectPostMutationError = HTTPErrorResponse

    /**
 * @summary Collect Data
 */
export const useCollectDataApiV1MlCollectPost = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof collectDataApiV1MlCollectPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getCollectDataApiV1MlCollectPostMutationOptions(options), queryClient);
    }
    /**
 * Deprecated: Use /train-remote instead.

Local training is disabled to avoid OOM on 512MB Render.
Models are trained on HuggingFace Spaces (16GB RAM).
 * @summary Train Models
 */
export type trainModelsApiV1MlTrainPostResponse200 = {
  data: PipelineResponse
  status: 200
}

export type trainModelsApiV1MlTrainPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type trainModelsApiV1MlTrainPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type trainModelsApiV1MlTrainPostResponseSuccess = (trainModelsApiV1MlTrainPostResponse200) & {
  headers: Headers;
};
export type trainModelsApiV1MlTrainPostResponseError = (trainModelsApiV1MlTrainPostResponse401 | trainModelsApiV1MlTrainPostResponse403) & {
  headers: Headers;
};

export type trainModelsApiV1MlTrainPostResponse = (trainModelsApiV1MlTrainPostResponseSuccess | trainModelsApiV1MlTrainPostResponseError)

export const getTrainModelsApiV1MlTrainPostUrl = () => {


  

  return `/api/v1/ml/train`
}

export const trainModelsApiV1MlTrainPost = async ( options?: RequestInit): Promise<trainModelsApiV1MlTrainPostResponse> => {
  
  return customInstance<trainModelsApiV1MlTrainPostResponse>(getTrainModelsApiV1MlTrainPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getTrainModelsApiV1MlTrainPostMutationOptions = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, TError,void, TContext> => {

const mutationKey = ['trainModelsApiV1MlTrainPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, void> = () => {
          

          return  trainModelsApiV1MlTrainPost(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TrainModelsApiV1MlTrainPostMutationResult = NonNullable<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>>
    
    export type TrainModelsApiV1MlTrainPostMutationError = HTTPErrorResponse

    /**
 * @summary Train Models
 */
export const useTrainModelsApiV1MlTrainPost = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof trainModelsApiV1MlTrainPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getTrainModelsApiV1MlTrainPostMutationOptions(options), queryClient);
    }
    /**
 * Deprecated: Use /train-remote instead.

Local ML pipeline is disabled to avoid OOM on 512MB Render.
Models are trained on HuggingFace Spaces (16GB RAM).
 * @summary Run Full Pipeline
 */
export type runFullPipelineApiV1MlRunFullPostResponse200 = {
  data: PipelineResponse
  status: 200
}

export type runFullPipelineApiV1MlRunFullPostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type runFullPipelineApiV1MlRunFullPostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type runFullPipelineApiV1MlRunFullPostResponseSuccess = (runFullPipelineApiV1MlRunFullPostResponse200) & {
  headers: Headers;
};
export type runFullPipelineApiV1MlRunFullPostResponseError = (runFullPipelineApiV1MlRunFullPostResponse401 | runFullPipelineApiV1MlRunFullPostResponse403) & {
  headers: Headers;
};

export type runFullPipelineApiV1MlRunFullPostResponse = (runFullPipelineApiV1MlRunFullPostResponseSuccess | runFullPipelineApiV1MlRunFullPostResponseError)

export const getRunFullPipelineApiV1MlRunFullPostUrl = () => {


  

  return `/api/v1/ml/run-full`
}

export const runFullPipelineApiV1MlRunFullPost = async ( options?: RequestInit): Promise<runFullPipelineApiV1MlRunFullPostResponse> => {
  
  return customInstance<runFullPipelineApiV1MlRunFullPostResponse>(getRunFullPipelineApiV1MlRunFullPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getRunFullPipelineApiV1MlRunFullPostMutationOptions = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, TError,void, TContext> => {

const mutationKey = ['runFullPipelineApiV1MlRunFullPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, void> = () => {
          

          return  runFullPipelineApiV1MlRunFullPost(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RunFullPipelineApiV1MlRunFullPostMutationResult = NonNullable<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>>
    
    export type RunFullPipelineApiV1MlRunFullPostMutationError = HTTPErrorResponse

    /**
 * @summary Run Full Pipeline
 */
export const useRunFullPipelineApiV1MlRunFullPost = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof runFullPipelineApiV1MlRunFullPost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getRunFullPipelineApiV1MlRunFullPostMutationOptions(options), queryClient);
    }
    /**
 * Get current pipeline execution status.

Returns whether a pipeline task is running and the result of the last run.
 * @summary Get Pipeline Status
 */
export type getPipelineStatusApiV1MlPipelineStatusGetResponse200 = {
  data: PipelineResponse
  status: 200
}

export type getPipelineStatusApiV1MlPipelineStatusGetResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type getPipelineStatusApiV1MlPipelineStatusGetResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type getPipelineStatusApiV1MlPipelineStatusGetResponseSuccess = (getPipelineStatusApiV1MlPipelineStatusGetResponse200) & {
  headers: Headers;
};
export type getPipelineStatusApiV1MlPipelineStatusGetResponseError = (getPipelineStatusApiV1MlPipelineStatusGetResponse401 | getPipelineStatusApiV1MlPipelineStatusGetResponse403) & {
  headers: Headers;
};

export type getPipelineStatusApiV1MlPipelineStatusGetResponse = (getPipelineStatusApiV1MlPipelineStatusGetResponseSuccess | getPipelineStatusApiV1MlPipelineStatusGetResponseError)

export const getGetPipelineStatusApiV1MlPipelineStatusGetUrl = () => {


  

  return `/api/v1/ml/pipeline-status`
}

export const getPipelineStatusApiV1MlPipelineStatusGet = async ( options?: RequestInit): Promise<getPipelineStatusApiV1MlPipelineStatusGetResponse> => {
  
  return customInstance<getPipelineStatusApiV1MlPipelineStatusGetResponse>(getGetPipelineStatusApiV1MlPipelineStatusGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPipelineStatusApiV1MlPipelineStatusGetQueryKey = () => {
    return [
    `/api/v1/ml/pipeline-status`
    ] as const;
    }

    
export const getGetPipelineStatusApiV1MlPipelineStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPipelineStatusApiV1MlPipelineStatusGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>> = ({ signal }) => getPipelineStatusApiV1MlPipelineStatusGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPipelineStatusApiV1MlPipelineStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>>
export type GetPipelineStatusApiV1MlPipelineStatusGetQueryError = HTTPErrorResponse


export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Pipeline Status
 */

export function useGetPipelineStatusApiV1MlPipelineStatusGet<TData = Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError = HTTPErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPipelineStatusApiV1MlPipelineStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPipelineStatusApiV1MlPipelineStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get finished matches for ML training (API key protected).

This endpoint is called by HuggingFace Spaces to fetch training data.
Requires X-API-Key header matching HF_TRAINING_API_KEY env var.

Returns matches with:
- Team stats (attack, defense, ELO)
- Form and fatigue metrics
- Result (0=home_win, 1=draw, 2=away_win)
 * @summary Get Training Data
 */
export type getTrainingDataApiV1MlTrainingDataGetResponse200 = {
  data: TrainingDataResponse
  status: 200
}

export type getTrainingDataApiV1MlTrainingDataGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getTrainingDataApiV1MlTrainingDataGetResponseSuccess = (getTrainingDataApiV1MlTrainingDataGetResponse200) & {
  headers: Headers;
};
export type getTrainingDataApiV1MlTrainingDataGetResponseError = (getTrainingDataApiV1MlTrainingDataGetResponse422) & {
  headers: Headers;
};

export type getTrainingDataApiV1MlTrainingDataGetResponse = (getTrainingDataApiV1MlTrainingDataGetResponseSuccess | getTrainingDataApiV1MlTrainingDataGetResponseError)

export const getGetTrainingDataApiV1MlTrainingDataGetUrl = (params?: GetTrainingDataApiV1MlTrainingDataGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/ml/training-data?${stringifiedParams}` : `/api/v1/ml/training-data`
}

export const getTrainingDataApiV1MlTrainingDataGet = async (params?: GetTrainingDataApiV1MlTrainingDataGetParams, options?: RequestInit): Promise<getTrainingDataApiV1MlTrainingDataGetResponse> => {
  
  return customInstance<getTrainingDataApiV1MlTrainingDataGetResponse>(getGetTrainingDataApiV1MlTrainingDataGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTrainingDataApiV1MlTrainingDataGetQueryKey = (params?: GetTrainingDataApiV1MlTrainingDataGetParams,) => {
    return [
    `/api/v1/ml/training-data`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetTrainingDataApiV1MlTrainingDataGetQueryOptions = <TData = Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError = HTTPValidationError>(params?: GetTrainingDataApiV1MlTrainingDataGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTrainingDataApiV1MlTrainingDataGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>> = ({ signal }) => getTrainingDataApiV1MlTrainingDataGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTrainingDataApiV1MlTrainingDataGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>>
export type GetTrainingDataApiV1MlTrainingDataGetQueryError = HTTPValidationError


export function useGetTrainingDataApiV1MlTrainingDataGet<TData = Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError = HTTPValidationError>(
 params: undefined |  GetTrainingDataApiV1MlTrainingDataGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>,
          TError,
          Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTrainingDataApiV1MlTrainingDataGet<TData = Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError = HTTPValidationError>(
 params?: GetTrainingDataApiV1MlTrainingDataGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>,
          TError,
          Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTrainingDataApiV1MlTrainingDataGet<TData = Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError = HTTPValidationError>(
 params?: GetTrainingDataApiV1MlTrainingDataGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Training Data
 */

export function useGetTrainingDataApiV1MlTrainingDataGet<TData = Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError = HTTPValidationError>(
 params?: GetTrainingDataApiV1MlTrainingDataGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTrainingDataApiV1MlTrainingDataGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTrainingDataApiV1MlTrainingDataGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Trigger model training on HuggingFace Spaces.

This endpoint:
1. Fetches training data from database (finished matches with stats)
2. Sends data to HuggingFace /train endpoint
3. Returns training results (accuracy, feature importance)

Requires admin authentication.
 * @summary Train On Huggingface
 */
export type trainOnHuggingfaceApiV1MlTrainRemotePostResponse200 = {
  data: HFTrainingResponse
  status: 200
}

export type trainOnHuggingfaceApiV1MlTrainRemotePostResponse401 = {
  data: HTTPErrorResponse
  status: 401
}

export type trainOnHuggingfaceApiV1MlTrainRemotePostResponse403 = {
  data: HTTPErrorResponse
  status: 403
}
    
export type trainOnHuggingfaceApiV1MlTrainRemotePostResponseSuccess = (trainOnHuggingfaceApiV1MlTrainRemotePostResponse200) & {
  headers: Headers;
};
export type trainOnHuggingfaceApiV1MlTrainRemotePostResponseError = (trainOnHuggingfaceApiV1MlTrainRemotePostResponse401 | trainOnHuggingfaceApiV1MlTrainRemotePostResponse403) & {
  headers: Headers;
};

export type trainOnHuggingfaceApiV1MlTrainRemotePostResponse = (trainOnHuggingfaceApiV1MlTrainRemotePostResponseSuccess | trainOnHuggingfaceApiV1MlTrainRemotePostResponseError)

export const getTrainOnHuggingfaceApiV1MlTrainRemotePostUrl = () => {


  

  return `/api/v1/ml/train-remote`
}

export const trainOnHuggingfaceApiV1MlTrainRemotePost = async ( options?: RequestInit): Promise<trainOnHuggingfaceApiV1MlTrainRemotePostResponse> => {
  
  return customInstance<trainOnHuggingfaceApiV1MlTrainRemotePostResponse>(getTrainOnHuggingfaceApiV1MlTrainRemotePostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getTrainOnHuggingfaceApiV1MlTrainRemotePostMutationOptions = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainOnHuggingfaceApiV1MlTrainRemotePost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof trainOnHuggingfaceApiV1MlTrainRemotePost>>, TError,void, TContext> => {

const mutationKey = ['trainOnHuggingfaceApiV1MlTrainRemotePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainOnHuggingfaceApiV1MlTrainRemotePost>>, void> = () => {
          

          return  trainOnHuggingfaceApiV1MlTrainRemotePost(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TrainOnHuggingfaceApiV1MlTrainRemotePostMutationResult = NonNullable<Awaited<ReturnType<typeof trainOnHuggingfaceApiV1MlTrainRemotePost>>>
    
    export type TrainOnHuggingfaceApiV1MlTrainRemotePostMutationError = HTTPErrorResponse

    /**
 * @summary Train On Huggingface
 */
export const useTrainOnHuggingfaceApiV1MlTrainRemotePost = <TError = HTTPErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainOnHuggingfaceApiV1MlTrainRemotePost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof trainOnHuggingfaceApiV1MlTrainRemotePost>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getTrainOnHuggingfaceApiV1MlTrainRemotePostMutationOptions(options), queryClient);
    }
    